// Start of user code Copyright
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *       Sam Padgett          - initial API and implementation
 *     Michael Fiedler      - adapted for OSLC4J
 *     Jad El-khoury        - initial implementation of code generator (422448)
 *     Matthieu Helleboid   - Support for multiple Service Providers.
 *     Anass Radouani       - Support for multiple Service Providers.
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/
// End of user code

package com.ibm.oslc.adaptor.iotp.resources;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.text.SimpleDateFormat;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.Iterator;
import javax.servlet.http.HttpServletRequest;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import javax.ws.rs.core.UriBuilder;

import org.eclipse.lyo.oslc4j.core.OSLC4JUtils;
import org.eclipse.lyo.oslc4j.core.exception.OslcCoreApplicationException;
import org.eclipse.lyo.oslc4j.core.annotation.OslcAllowedValue;
import org.eclipse.lyo.oslc4j.core.annotation.OslcDescription;
import org.eclipse.lyo.oslc4j.core.annotation.OslcMemberProperty;
import org.eclipse.lyo.oslc4j.core.annotation.OslcName;
import org.eclipse.lyo.oslc4j.core.annotation.OslcNamespace;
import org.eclipse.lyo.oslc4j.core.annotation.OslcOccurs;
import org.eclipse.lyo.oslc4j.core.annotation.OslcPropertyDefinition;
import org.eclipse.lyo.oslc4j.core.annotation.OslcRange;
import org.eclipse.lyo.oslc4j.core.annotation.OslcReadOnly;
import org.eclipse.lyo.oslc4j.core.annotation.OslcRepresentation;
import org.eclipse.lyo.oslc4j.core.annotation.OslcResourceShape;
import org.eclipse.lyo.oslc4j.core.annotation.OslcTitle;
import org.eclipse.lyo.oslc4j.core.annotation.OslcValueType;
import org.eclipse.lyo.oslc4j.core.model.AbstractResource;
import org.eclipse.lyo.oslc4j.core.model.Link;
import org.eclipse.lyo.oslc4j.core.model.Occurs;
import org.eclipse.lyo.oslc4j.core.model.OslcConstants;
import org.eclipse.lyo.oslc4j.core.model.Representation;
import org.eclipse.lyo.oslc4j.core.model.ValueType;
import org.eclipse.lyo.oslc4j.core.model.ResourceShape;
import org.eclipse.lyo.oslc4j.core.model.ResourceShapeFactory;

import com.ibm.oslc.adaptor.iotp.resources.Oslc_iotDomainConstants;
import com.ibm.oslc.adaptor.iotp.resources.Oslc_iotDomainConstants;
import com.ibm.oslc.adaptor.iotp.resources.Person;
import com.ibm.oslc.adaptor.iotp.resources.Person;
import com.ibm.oslc.adaptor.iotp.resources.Discussion;
import com.ibm.oslc.adaptor.iotp.resources.Schema;

// Start of user code imports
import org.eclipse.lyo.oslc4j.core.model.ServiceProvider;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.ibm.oslc.adaptor.iotp.servlet.ServiceProviderCatalogSingleton;
import com.ibm.oslc.adaptor.iotp.IotpServiceProviderInfo;
// End of user code

// Start of user code preClassCode
// End of user code

// Start of user code classAnnotations
// End of user code
@OslcNamespace(Oslc_iotDomainConstants.LOGICALINTERFACE_NAMESPACE)
@OslcName(Oslc_iotDomainConstants.LOGICALINTERFACE_LOCALNAME)
@OslcResourceShape(title = "LogicalInterface Resource Shape", describes = Oslc_iotDomainConstants.LOGICALINTERFACE_TYPE)
public class LogicalInterface
    extends Resource
    implements ILogicalInterface
{
    // Start of user code attributeAnnotation:schema
    // End of user code
    private Link schema = new Link();
    
    // Start of user code classAttributes
    // End of user code
    // Start of user code classMethods
	public LogicalInterface(final HttpServletRequest httpServletRequest, final IotpServiceProviderInfo info, final String id, JsonObject jsonObject)
			throws URISyntaxException {
		super(id, jsonObject);
		// Rules: Don't set anything where there is no value.
		// E.g. if there is no representation, don't set the value.

		// Set some inherited oslc_am:Resource properties that need to be set by the
		// subclass
		// IoT Platform resources need to be marked with rdf:types that the CLM apps can
		// link to
		// All cross-server links are fixed and hard-coded, so we have to do this to
		// create any links
		// This is also influenced by where the links can be stored - either directly or
		// as backlinks
		getTypes().add(new URI("http://open-services.net/ns/cm#ChangeRequest"));
		getTypes().add(new URI("http://open-services.net/ns/rm#Requirement"));

		// Note that there must be a service provider since we are creating an instance
		// of an resource
		// Therefore there will be no need to refresh the catalog
		ServiceProvider serviceProvider = ServiceProviderCatalogSingleton.getIotpServiceProvider(httpServletRequest, info.iotId);
		HashSet<URI> serviceProviders = new HashSet<URI>();
		serviceProviders.add(serviceProvider.getAbout());
		setServiceProvider(serviceProviders);
		setAbout(constructURI(info.iotId, id));
		try {
			setInstanceShape(createResourceShape().getAbout());
		} catch (OslcCoreApplicationException e) {
		}

		// properties for IotLogicalInterface:
		// id: setter from base class, NO OP
		// name: use "name" to set IResource.title in base class
		// description: setter from base class, NO OP
		// version: Not modeled, NO OP
		// created: use "created" to setCreated in IResource.created in base class
		// createdBy: use "createdBy" to setCreator and setContributor in
		// IResource.creator in base class with these steps:
		// a) casting string to URI b) casting URI to Link, c) casting Link to
		// HashSet<Link>
		// Note: multiple creators are listed in the same String with delimiters
		// updated: use "updated" to set IResource.modified in base class
		// updatedBy: use "updatedBy" to add IResource.Contributors in base class
		// refs.schema: set refs Link schema
		// schemaId: use addTypes HashSet<Link> with prefix "schemaId:"
		// sample Link: "schemaId:5829e2c546e0fb0001cf0ac4"

		// name: map to IResource.title in base class
		JsonElement element = jsonObject.get("name");
		if (element != null)
			this.setTitle(element.getAsString());

		// created: cast string to Date then set "created"
		element = jsonObject.get("created");
		if (element != null) {
			try {
				Date createDate = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssX").parse(element.getAsString());
				this.setCreated(createDate);
			} catch (Exception e) {
			}
		}

		// createdBy: map to IResource.creator in base class
		// a) casting string to URI b) casting URI to Link, c) casting Link to
		// HashSet<Link>
		// d) setCreator(HashSet<Link>)
		// Note: multiple creators are listed in the same String with delimiters
		element = jsonObject.get("createdBy");
		if (element != null) {
			try {
				HashSet<Link> createdbyT = new HashSet<Link>();
				URI createdbyURI = new URI("mailto:" + element.getAsString());
				Link createdbyLink = new Link(createdbyURI);
				createdbyT.add(createdbyLink);
				this.setCreator(createdbyT);
				this.setContributor(createdbyT);
			} catch (Exception e) {

			}
		}

		// updated: map to IResource.modified in base class
		element = jsonObject.get("updated");
		if (element != null) {
			try {
				Date updateDate = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse(element.getAsString());
				this.setModified(updateDate);
			} catch (Exception e) {
			}
		}

		// updatedBy: use "updatedBy" to set IResource.Contributors in base class
		element = jsonObject.get("updateBy");
		if (element != null) {
			try {
				// first contributor was already set to be the same as the creator, therefore it
				// has "mailto:"
				Link existingContributorsLink = (Link) this.getContributor().toArray()[0];
				// keep appending by adding ";" with the new contributor
				URI updatedByURI = new URI(existingContributorsLink.toString() + ";" + element.getAsString());
				Link updatedByLink = new Link(updatedByURI);
				HashSet<Link> updatedByT = new HashSet<Link>();
				updatedByT.add(updatedByLink);
				this.setContributor(updatedByT);
			} catch (Exception e) {
			}
		}

		// schemaId has the same information as refs.schema
		element = jsonObject.get("schemaId");
		if (element != null) {
			String schemaId = element.getAsString();
			Link link = Schema.constructLink(info.iotId, schemaId);
			link.setLabel(schemaId);
			this.setSchema(link);
		}
	}
		
    public JsonElement toJson() {
    	    JsonObject json = super.toJson().getAsJsonObject();
    	    
    		// properties for IotLogicalInterface:
    		// id:			get "id" from getIdentifier() in base class
    		// name:			get "name" from getTitle() in base class
    		// description:	get "description" from getDescription() in base class
    		// version:    	not modeled 
    		// created:		get "created" from getCreated() in base class, cast Date to String
    		// createdBy:	get "createdBy" from getCreator() in base class, cast HashSet<Link> to Link; cast Link to URI, cast URI to String
    		//             	Note: multiple creators are in the same String variable 	    
    		// updated:   	get "updated" from getModified() in base class, cast Date to String
    		// updatedBy: 	get "updatedBy" from getContributors() in base class
    		// refs.schema:	get from Link schema
    		// schemaId:    use getTypes HashSet<Link> with prefix "schemaId:"
    		//			    sample Link: "schemaId:5829e2c546e0fb0001cf0ac4"   
		
    		json.addProperty("id", getIdentifier());
    		json.addProperty("name", getTitle());
		json.addProperty("description", getDescription());
		
		// created: get "created" from getCreated() in base class, cast Date to String
		try {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssX");
			String dateString =  dateFormat.format(getCreated());
			json.addProperty("created", dateString);
		} catch(Exception e) {
		}
		
   		// createdBy: use getCreator() in base class, cast HashSet<Link> to Link; cast Link to URI, cast URI to String
		//            Note: multiple creators are in the same String variable
		Link createdBy = (Link) getCreator().toArray()[0];
		if (createdBy != null) 
		{
		    URI createdbyURI = createdBy.getValue();
		    String stringURI = createdbyURI.toString(); 
		    // remove "mailto:" from the URI
		    stringURI.replaceAll("mailto:", "");
		    json.addProperty("createdBy", stringURI);
		}
		
		// updated: get "updated" from getModified() in base class, cast Date to String 
		Date updatedDate = getModified();
		if (updatedDate != null)
		{
		String dateString = "";	
		try {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
			dateString =  dateFormat.format(updatedDate);
		} catch(Exception exc) {
			System.out.println("Cannot parse date: "+exc.getMessage());
		}
		json.addProperty("updated", dateString);
		}
		
		// updatedBy:  	get from IResource.getContributors in base class 
		Link ContributorsLink = (Link) this.getContributor().toArray()[0];  
		if (ContributorsLink != null)
		{
		    URI contributorsURI = ContributorsLink.getValue();
		    String contributorsString = contributorsURI.toString();
		    // remove "mailto:" from the URI
		    contributorsString.replaceAll("mailto:", "");
		    json.addProperty("updatedBy",  contributorsString);
		}

		// refs.schema: these are fixed query URLs and should never be updated 
		// schemaId:  sample value: "5829e2c546e0fb0001cf0ac4"   
		if (this.getSchema() != null) json.addProperty("schemaId", this.getSchema().getLabel());

		return json;
    }    // End of user code
    public LogicalInterface()
           throws URISyntaxException
    {
        super();
    
        // Start of user code constructor1
        // End of user code
    }
    
    public LogicalInterface(final URI about)
           throws URISyntaxException
    {
        super(about);
    
        // Start of user code constructor2
        // End of user code
    }
    
    /**
    * @deprecated Use the methods in class {@link com.ibm.oslc.adaptor.iotp.CE4IoTConnectorResourcesFactory} instead.
    */
    @Deprecated
    public LogicalInterface(final String iotId, final String logicalInterfaceId)
           throws URISyntaxException
    {
        this (constructURI(iotId, logicalInterfaceId));
        // Start of user code constructor3
        // End of user code
    }
    
    /**
    * @deprecated Use the methods in class {@link com.ibm.oslc.adaptor.iotp.CE4IoTConnectorResourcesFactory} instead.
    */
    @Deprecated
    public static URI constructURI(final String iotId, final String logicalInterfaceId)
    {
        String basePath = OSLC4JUtils.getServletURI();
        Map<String, Object> pathParameters = new HashMap<String, Object>();
        pathParameters.put("iotId", iotId);
        pathParameters.put("logicalInterfaceId", logicalInterfaceId);
        String instanceURI = "iotp/{iotId}/resources/logicalInterfaces/{logicalInterfaceId}";
    
        final UriBuilder builder = UriBuilder.fromUri(basePath);
        return builder.path(instanceURI).buildFromMap(pathParameters);
    }
    
    /**
    * @deprecated Use the methods in class {@link com.ibm.oslc.adaptor.iotp.CE4IoTConnectorResourcesFactory} instead.
    */
    @Deprecated
    public static Link constructLink(final String iotId, final String logicalInterfaceId , final String label)
    {
        return new Link(constructURI(iotId, logicalInterfaceId), label);
    }
    
    /**
    * @deprecated Use the methods in class {@link com.ibm.oslc.adaptor.iotp.CE4IoTConnectorResourcesFactory} instead.
    */
    @Deprecated
    public static Link constructLink(final String iotId, final String logicalInterfaceId)
    {
        return new Link(constructURI(iotId, logicalInterfaceId));
    }
    
    public static ResourceShape createResourceShape() throws OslcCoreApplicationException, URISyntaxException {
        return ResourceShapeFactory.createResourceShape(OSLC4JUtils.getServletURI(),
        OslcConstants.PATH_RESOURCE_SHAPES,
        Oslc_iotDomainConstants.LOGICALINTERFACE_PATH,
        LogicalInterface.class);
    }
    
    
    public String toString()
    {
        return toString(false);
    }
    
    public String toString(boolean asLocalResource)
    {
        String result = "";
        // Start of user code toString_init
        // End of user code
    
        if (asLocalResource) {
            result = result + "{a Local LogicalInterface Resource} - update LogicalInterface.toString() to present resource as desired.";
            // Start of user code toString_bodyForLocalResource
            // End of user code
        }
        else {
            result = getAbout().toString();
        }
    
        // Start of user code toString_finalize
        // End of user code
    
        return result;
    }
    
    public String toHtml()
    {
        return toHtml(false);
    }
    
    public String toHtml(boolean asLocalResource)
    {
        String result = "";
        // Start of user code toHtml_init
        // End of user code
    
        if (asLocalResource) {
            result = toString(true);
            // Start of user code toHtml_bodyForLocalResource
            // End of user code
        }
        else {
            result = "<a href=\"" + getAbout() + "\" class=\"oslc-resource-link\">" + toString() + "</a>";
        }
    
        // Start of user code toHtml_finalize
        // End of user code
    
        return result;
    }
    
    
    // Start of user code getterAnnotation:schema
    // End of user code
    @OslcName("schema")
    @OslcPropertyDefinition(Oslc_iotDomainConstants.IOT_PLATFORM_NAMSPACE + "schema")
    @OslcOccurs(Occurs.ExactlyOne)
    @OslcValueType(ValueType.Resource)
    @OslcRange({Oslc_iotDomainConstants.SCHEMA_TYPE})
    @OslcReadOnly(false)
    @OslcTitle("schema")
    public Link getSchema()
    {
        // Start of user code getterInit:schema
        // End of user code
        return schema;
    }
    
    
    // Start of user code setterAnnotation:schema
    // End of user code
    public void setSchema(final Link schema )
    {
        // Start of user code setterInit:schema
        // End of user code
        this.schema = schema;
    
        // Start of user code setterFinalize:schema
        // End of user code
    }
    
    
    static public String schemaToHtmlForCreation (final HttpServletRequest httpServletRequest)
    {
        String s = "";
    
        // Start of user code "Init:schemaToHtmlForCreation(...)"
        // End of user code
    
        s = s + "<label for=\"schema\">schema: </LABEL>";
    
        // Start of user code "Mid:schemaToHtmlForCreation(...)"
        // End of user code
    
        // Start of user code "Finalize:schemaToHtmlForCreation(...)"
        // End of user code
    
        return s;
    }
    
    
    public String schemaToHtml()
    {
        String s = "";
    
        // Start of user code schematoHtml_mid
        // End of user code
    
        try {
            if ((schema == null) || (schema.getValue() == null)) {
                s = s + "<em>null</em>";
            }
            else {
                s = s + (new Schema (schema.getValue())).toHtml(false);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    
        // Start of user code schematoHtml_finalize
        // End of user code
    
        return s;
    }
    
    
}
